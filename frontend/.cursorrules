Frontend Design & Development Specification: Flutter Web Sharing Platform
Document Version: 1.0
Date: July 8, 2025
Project Name: Breeze
Module: Frontend

1. Project Overview & Core Purpose
   This document outlines the design and development specifications for the frontend of a platform designed to enable Flutter developers to instantly share their mobile applications as interactive web experiences. The primary goal is to provide a seamless bridge between Flutter's mobile capabilities and the universal accessibility of the web, allowing developers to showcase their apps without requiring downloads. The frontend will be "sleek, fancy, and modern," offering an intuitive user experience.

2. Target Audience
   The primary target audience consists of Flutter developers looking for an effortless way to share and demonstrate their mobile applications. This implies a need for clear technical information, efficient workflows, and a professional, performance-oriented interface.

3. Frontend Technology Stack
   Framework: Next.js (React.js)

Rationale: Leverages React's component-based architecture for rich UI, with Next.js providing critical optimizations like Server-Side Rendering (SSR) for fast initial page loads and SEO benefits on public-facing pages, alongside optimized static site generation.

Styling: Tailwind CSS

Rationale: Utility-first approach offers unparalleled flexibility for custom designs, precise control over the dark theme, and highly optimized, performant CSS output. Ideal for achieving a unique "sleek and fancy" aesthetic without fighting against opinionated component libraries.

State Management: Zustand

Rationale: Lightweight, performant, and simple state management library for React. Perfect for managing global UI state (theme, authentication, notifications, build status) with minimal boilerplate, promoting clean and efficient code.

Typography: Outfit (Google Font)

Rationale: Selected for its modern, geometric aesthetic, complementing the sleek and fancy design.

4. Core Design Principles & Aesthetic Goals
   Sleek & Modern: Clean lines, ample whitespace (even in dark mode), subtle animations, and sophisticated visual effects.

Fancy: High-quality graphics, smooth transitions, attention to detail in micro-interactions, and a premium feel.

Dark Theme First: The entire application will be designed with a dark background as the primary theme. Light mode will be an optional toggle if implemented in the future, but the default and optimized experience is dark.

Performance: Fast loading times (especially for public pages via Next.js SSR/SSG), smooth animations, and responsive interactions.

Responsiveness: Fully optimized for various screen sizes, from mobile phones to large desktop displays. A mobile-first design approach is encouraged.

Intuitive UX: Clear navigation, logical information architecture, and straightforward workflows for core tasks (e.g., deploying an app, checking build status).

Accessibility: Adherence to WCAG standards where possible. Focus on sufficient color contrast, keyboard navigability, and semantic HTML.

5. Frontend Features (Pages & Sections)
   A. Public-Facing Pages:
   Landing Page (Home - /):

Hero Section: Prominent headline, concise sub-headline, primary CTA ("Get Started for Free"), secondary CTA ("See a Live Demo"). Visual: Placeholder for a future Rive animation (mobile-to-web flow).

Problem & Solution: Briefly highlight the pain points of app sharing and how the platform solves them.

How It Works: Three-step process with clear icons: "Connect GitHub," "Automated Web Build," "Share & Experience."

Key Benefits: Grid/list of unique selling propositions (e.g., "Instant Accessibility," "True Cross-Platform Showcase," "Effortless Deployment").

Featured Apps Showcase: Curated carousel/grid of high-quality Flutter apps deployed on the platform with demo links.

Testimonials (Optional): Social proof from early users.

Final Call to Action: Prominent CTA encouraging signup.

Footer: Essential links (About Us, Contact, Privacy, Terms), social media icons.

Login/Sign Up Page (/login, /signup):

Primary "Continue with GitHub" button.

Optional: Email/password fields for alternative sign-up/login.

Links to Forgot Password, Terms of Service, Privacy Policy.

Minimalist, focused layout.

Pricing Page (/pricing - if applicable):

Clear presentation of pricing tiers (Free, Pro, Enterprise).

Feature comparison table.

FAQs related to pricing and features.

CTAs for "Choose Plan" or "Contact Sales."

About Us Page (/about):

Platform vision, mission, and brief story.

(Optional) Team members.

Contact Us Page (/contact):

Contact form (Name, Email, Subject, Message).

Direct support email address.

Links to relevant social media/community channels.

B. Authenticated Dashboard Pages:
Dashboard Home (/dashboard):

Purpose: Personalized overview for the logged-in user.

Content: "Welcome [User Name]", "My Active Apps" card (quick links to 2-3 recent apps), "Recent Activity/Builds" feed (latest build statuses), "Quick Actions" (e.g., "Deploy New App").

Layout: Modular grid of information widgets.

My Apps / Projects List (/dashboard/apps):

Purpose: Central management of all user's deployed projects.

Content:

Table or card-based list of apps with Name, Status (Building, Deployed, Failed), Last Updated, Public URL (with copy button), Views (future analytics).

"New App" button.

Search and filter functionalities.

Pagination for large lists.

Individual App Management Page (/dashboard/apps/[app-id]):

Purpose: Detailed control panel for a specific app.

Sections/Tabs:

Overview: App Name, current Status, prominently displayed Public URL (with copy button), Last Deployed timestamp, options to manually trigger a build or configure auto-build.

Builds & Logs: List of historical builds (status, timestamp, duration). Clickable entries to view detailed build logs (streamed from Go backend). "Trigger New Build" button.

Settings: Basic app info (name, associated GitHub repo/branch), deployment options (public/private toggle, custom domain configuration - future), and a "Danger Zone" with a "Delete App" action.

Analytics (Future): Simple visualizations for app usage (daily/monthly views, unique visitors, referral sources).

Account Settings (/dashboard/settings):

Profile: User name, email, password change.

GitHub Integration: View connected GitHub account, option to revoke/reconnect.

Billing (Future): Subscription details, payment methods, invoice history.

Security: (Future) Two-factor authentication (2FA) setup.

Notifications/Alerts:

In-app notification system (bell icon) for important events (e.g., build success/failure).

(Optional) A dedicated Notifications page.

6. Styling Guidelines (Tailwind CSS Implementation)
   Color Palette (Configured in tailwind.config.js):

Primary Background: dark-primary (e.g., #1A1A2E or similar deep, rich charcoal/dark blue/purple).

Surface/Card Backgrounds: dark-surface (e.g., #2D2D44 or slightly lighter shade of primary background).

Primary Accent: accent-teal (e.g., #3DCCB1 or Flutter-inspired vibrant teal/blue). Used for CTAs, active states, progress indicators.

Secondary Accent (Optional): accent-purple (e.g., #9C27B0). Used for secondary elements, distinct highlights.

Text Colors: text-light (e.g., #F5F5F5 for high-emphasis), text-muted (e.g., #B0B0B0 for body), text-dim (e.g., #757575 for hints/disabled).

Semantic Colors: error-red (#FF5252), success-green (#4CAF50), warning-yellow (#FFC107).

Typography (Defined in tailwind.config.js and applied globally/contextually):

Font Family: font-outfit (ensure Outfit font is loaded via @import in globals.css or Next.js Font Optimization).

Hierarchy: Clear hierarchy using text-xs to text-5xl with varying font weights (font-light, font-normal, font-medium, font-semibold, font-bold, font-extrabold). Use bold/extrabold Outfit for headlines and titles.

Readability: Ensure sufficient line-height and letter-spacing for all text on dark backgrounds.

UI Components:

Buttons: rounded-lg or rounded-full for shape. Primary buttons use bg-accent-teal text-text-light. Secondary buttons use border border-text-muted text-text-muted hover:border-accent-teal hover:text-accent-teal. Subtle transition for hover effects.

Input Fields: bg-dark-surface, text-text-light, border border-dark-surface-light, focus:border-accent-teal, rounded-md or rounded-lg. Placeholder text should use text-text-dim.

Cards/Panels: bg-dark-surface, rounded-xl, p-6. Apply subtle shadow-lg with a very light color (shadow-white/5 or shadow-accent-teal/5) for a "glowing" or lifted effect.

Navigation: Clean, potentially fixed sidebar or top navigation. Active links highlighted with text-accent-teal and/or an underline or border-b.

Icons: Minimalist, line-art or filled icons, styled with text-text-light or text-accent-teal.

Animations & Transitions:

Utilize Tailwind's built-in transition utilities for smooth hover states, focus states, and state changes.

Implement subtle custom CSS animations or use a library like Framer Motion for more complex entrance animations (e.g., component fade-ins, Rive animation on landing).

7. State Management Strategy (Zustand)
   Global Stores:

useThemeStore: Manages isDarkMode state and toggleDarkMode actions, persisting theme preference to localStorage.

useAuthStore: Manages user object, token, and isLoading for authentication status. Contains login and logout actions (which will interact with the Go backend).

useNotificationStore: For displaying global toast messages or alerts.

useBuildQueueStore: (Future) To track the status of builds globally, updating UI components across the dashboard.

Local Component State: For highly specific component-level state that doesn't need to be shared (e.g., form input values, modal open/close).

Data Fetching: For fetching data from the Go backend, use a library like react-query (TanStack Query) or SWR for caching, revalidation, and simplified async state management.

8. Development Considerations & Best Practices
   Component-Driven Development: Build small, reusable components (e.g., Button, Input, Card, Modal) first, then compose them into pages.

Atomic Design Principles: Consider organizing components by atomic categories (atoms, molecules, organisms, templates, pages) for scalability.

UI Libraries/Helpers:

Headless UI / Radix UI: For accessible, unstyled primitives that integrate seamlessly with Tailwind.

shadcn/ui: As a strong option to copy-paste pre-built (but customizable with Tailwind) components for rapid dashboard development.

Code Quality: Enforce ESLint and Prettier rules for consistent code formatting and error prevention.

TypeScript: Use TypeScript throughout the frontend for type safety and improved developer experience.

Testing: Implement unit tests for critical components (e.g., with Jest/React Testing Library) and integration tests for key user flows.

<!-- Build Pipeline: Ensure npm run build (Next.js release build) is optimized for production, leveraging dart2js for Flutter web app compilation, and deploying static assets to a CDN for optimal performance. -->

Continuous Integration/Deployment (CI/CD): Automate builds and deployments of the frontend to your hosting environment (e.g., Vercel for Next.js, Netlify, or self-hosted static file serving).
